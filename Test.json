{
    "cells": [
     {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
       "# Markov Chain Models in Neo4j with Random Walks\n",
       "\n",
       "This notebook implements various random walk models using Markov Chains in Neo4j."
      ]
     },
     {
      "cell_type": "code",
      "execution_count": 1,
      "metadata": {},
      "outputs": [],
      "source": [
       "from py2neo import Graph\n",
       "import numpy as np\n",
       "import random\n",
       "\n",
       "# Connect to Neo4j\n",
       "graph = Graph(\"bolt://localhost:7687\", auth=(\"neo4j\", \"password\"))\n"
      ]
     },
     {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
       "## Function to Create Markov Chain in Neo4j"
      ]
     },
     {
      "cell_type": "code",
      "execution_count": 2,
      "metadata": {},
      "outputs": [],
      "source": [
       "def create_markov_chain(graph, transition_matrix):\n",
       "    N = len(transition_matrix)\n",
       "    graph.run(\"MATCH (n) DETACH DELETE n\")\n",
       "\n",
       "    for i in range(N):\n",
       "        graph.run(\"CREATE (:State {name: $name, current: 0})\", name=f'S{i}')\n",
       "\n",
       "    for i in range(N):\n",
       "        for j in range(N):\n",
       "            probability = transition_matrix[i][j]\n",
       "            if probability > 0:\n",
       "                graph.run(\"MATCH (a:State {name: $from_state}), (b:State {name: $to_state}) CREATE (a)-[:TO {probability: $prob}]->(b)\",\n",
       "                         from_state=f'S{i}', to_state=f'S{j}', prob=probability)\n",
       "    print(\"Markov Chain created.\")\n",
       "    print(np.array(transition_matrix))"
      ]
     },
     {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
       "## Random Walk Simulation"
      ]
     },
     {
      "cell_type": "code",
      "execution_count": 3,
      "metadata": {},
      "outputs": [],
      "source": [
       "def simulate_random_walk(graph, start_state, steps=10):\n",
       "    current_state = start_state\n",
       "\n",
       "    for step in range(steps):\n",
       "        print(f'Step {step+1}: Current State -> {current_state}')\n",
       "        graph.run(\"MATCH (s:State) SET s.current = 0\")\n",
       "        graph.run(\"MATCH (s:State {name: $state}) SET s.current = 1\", state=current_state)\n",
       "\n",
       "        result = graph.run(\"MATCH (s:State {name: $state})-[r:TO]->(n) RETURN n.name AS next_state, r.probability AS prob\",\n",
       "                         state=current_state).data()\n",
       "\n",
       "        if not result:\n",
       "            print(\"No transitions available. Stopping simulation.\")\n",
       "            break\n",
       "\n",
       "        next_states = [record[\"next_state\"] for record in result]\n",
       "        probabilities = [record[\"prob\"] for record in result]\n",
       "        current_state = random.choices(next_states, probabilities)[0]\n",
       "\n",
       "    print(f'Final State after {steps} steps: {current_state}')"
      ]
     },
     {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
       "## Example: Balanced Random Walk"
      ]
     },
     {
      "cell_type": "code",
      "execution_count": 4,
      "metadata": {},
      "outputs": [],
      "source": [
       "def balanced_random_walk(N):\n",
       "    matrix = np.zeros((N, N))\n",
       "    for i in range(N):\n",
       "        if i > 0:\n",
       "            matrix[i][i - 1] = 0.5\n",
       "        if i < N - 1:\n",
       "            matrix[i][i + 1] = 0.5\n",
       "    return matrix\n",
       "\n",
       "N = 5\n",
       "balanced_matrix = balanced_random_walk(N)\n",
       "create_markov_chain(graph, balanced_matrix)\n",
       "simulate_random_walk(graph, start_state='S2', steps=10)"
      ]
     }
    ],
    "metadata": {
     "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
     },
     "language_info": {
      "codemirror_mode": {
       "name": "ipython",
       "version": 3
      },
      "file_extension": ".py",
      "mimetype": "text/x-python",
      "name": "python",
      "nbconvert_exporter": "python",
      "pygments_lexer": "ipython3",
      "version": "3.8"
     }
    },
    "nbformat": 4,
    "nbformat_minor": 4
   }
   